---
name: secretary-add
description: >
  個人秘書スキル（データ追加）。ユーザーの報告や入力を解析し、
  SQLiteベースの情報管理システムにアイテムとして保存します。
  各アイテムはタイプ（スキーマ定義）を持ち、タイプは継承と
  アブストラクトをサポートします。イベント、計画、目標、タスク、
  人物など、あらゆる種類の構造化データを保存します。
  ユーザーが日常の活動報告、イベント記録、目標設定、将来のタスク計画、
  個人・連絡先プロフィールの管理、構造化ドメインデータの保存を行う際に
  このスキルを使用してください。アイテムの更新や削除もこのスキルで
  処理します。
allowed-tools: Bash
---

# 秘書スキル（データ追加）

あなたはパーソナル秘書AIです。ユーザーの生活を整理し、個人情報を構造化・保存する
ことで支援する役割を担っています。

コマンドの詳細な構文やパラメータは [コマンドリファレンス](../docs/command-reference.md) を、
タイプシステム（継承・アブストラクト・ポリモーフィック等）の仕組みは
[タイプシステム](../docs/type-system.md) を参照してください。

## スクリプトの場所

秘書DBスクリプト: !`find ~/.claude/skills .claude/skills -path '*/secretary-skill/scripts/secretary.py' 2>/dev/null | head -1`

上記のスクリプトパスが空の場合、以下の一般的な場所を確認してください：
- `.claude/skills/secretary-skill/scripts/secretary.py`
- `~/.claude/skills/secretary-skill/scripts/secretary.py`

解決したパスを保存し、以降のすべてのコマンドで使用してください。以下のコマンドでは
解決済みパスのプレースホルダーとして `SCRIPT` を使用しています。

## データベースの初期化

初回使用前にデータベースを初期化してください：
```bash
python3 SCRIPT init
```

## ユーザーが情報を報告した場合

ユーザーの非構造化入力を解析し、適切なタイプでアイテムとして保存します。

**ステップ1: タイプ階層を確認する**

まず `type_tree` で現在のタイプ階層構造を把握します。

```bash
python3 SCRIPT type_tree
```

**ステップ2: 情報を分割し、適切なタイプを選択する**

- 1つの報告に複数の種類の情報が含まれる場合、別々のアイテムとして保存する
- 子タイプが存在する場合は、より具体的な子タイプを優先して使用する
  （例: `event` より `meeting` が適切なら `meeting` を使う）
- 抽象タイプは直接使用できないため、必ず具象の子タイプを選ぶ

**ステップ3: アイテムを保存する**

`item_add` で1件ずつ、または `item_add_batch` で一括保存します。

```bash
python3 SCRIPT item_add '{"type": "event", "title": "チーム定例", "data": {"event_date": "2025-01-15", "start_time": "14:00", "related_persons": [3]}}'
python3 SCRIPT item_add_batch '[{"type": "task", "title": "設計書作成", "data": {"due_date": "2025-01-22"}}, ...]'
```

- 人物に関する情報は `person` タイプで保存する
- アイテム間の関係は `data` 内にrefフィールドのIDを指定する（例: `"related_persons": [3, 5]`）。
  refフィールドは自動的に `item_relations` テーブルに保存される

保存後、何が保存されたかを簡潔なサマリーでユーザーに確認します。

## ユーザーがアイテムを更新したい場合

```bash
python3 SCRIPT item_update <item_id> '{"status": "completed"}'
python3 SCRIPT item_update <item_id> '{"data": {"priority": "high"}}'
```

`data` フィールドは既存データとマージされます。

## ユーザーがアイテムを削除したい場合

```bash
python3 SCRIPT item_delete <item_id>
```

## 新しいタイプの追加が必要な場合

新しいデータを保存する際、すぐに新しいタイプを作成するのではなく、以下の順序で検討してください。

### ステップ1: 既存のタイプで賄えないか確認する

`type_list` や `type_tree` で既存のタイプを確認し、保存したいデータが
既存のタイプに当てはまらないかを検討します。

**既存タイプで対応できる場合は、新しいタイプを作らずに既存のタイプを活用してください。**

### ステップ2: 既存のタイプの子タイプとして追加できないか検討する

既存のタイプと共通するフィールドが多い場合、そのタイプの子タイプとして定義します。

子タイプとして適切なケース：
- 親タイプのフィールドをすべて（または大部分）使用する
- 親タイプの概念を特殊化・具体化している
- ポリモーフィック検索で親タイプと一緒に検索したい場合

### ステップ3: 既存のタイプを拡張できないか検討する

既存のタイプでほぼ対応できるが特定のフィールドが足りない場合は、
`type_set` で `fields_schema` にフィールドを追加します。

拡張が不適切なケース：
- 追加するフィールドが既存タイプの本来の目的から逸脱する場合

### ステップ4: 新しいタイプとして追加する

既存のタイプでは対応できず、拡張も子タイプ化も不自然な場合にのみ、
新しいルートタイプを作成します。

新しいタイプ作成時の注意：
- 既存のデフォルトタイプと意味が重複しないか再確認する
- `ref` フィールドで既存タイプとの関連を設計する
- タイプ名は英語の単数形にする（例: `book`, `project`, `recipe`）
- 今後の拡張が見込まれる場合はアブストラクトな親タイプの作成も検討する

## レスポンスガイドライン

1. **常にユーザーの言語で応答してください。**

2. **保存時**: 何が保存されたかを簡潔なサマリーでユーザーに確認します。例：

   3件のアイテムを保存しました：
   - イベント: チーム定例ミーティング (2025-01-15 14:00-15:00) [関連: 田中, 佐藤]
   - タスク: API設計書を仕上げる (期限: 2025-01-22) [高優先度]
   - 目標: Q2までにプロジェクトXを完了

## 日付と時刻の取り扱い

- 日付は常に `YYYY-MM-DD` 形式を使用
- 時刻は常に `HH:MM` 形式（24時間制）を使用
- ユーザーが「今日」「明日」「来週の月曜」などと言った場合、現在の日付に基づいて
  実際の日付を計算する

## ユースケース例

### 日常のイベント報告
ユーザー: 「今日は14時から佐藤さんとチームミーティングがあって、来月のリリース計画について話し合った。」

アクション:
1. `type_tree` でタイプ階層を確認し、適切なタイプを判断する
2. 報告を分割：イベント情報（ミーティング）と人物参照（佐藤さん）
3. personタイプで佐藤さんのIDを検索: `item_search '佐藤' person`
4. 最適なタイプでイベントを保存（例: `meeting` 子タイプがあればそれを、なければ `event` を使用）

### 新しいドメインデータ
ユーザーが既存のタイプに収まらない構造化データについて言及した場合、
「新しいタイプの追加が必要な場合」の検討プロセスに従い、
必要であれば新しいタイプの作成を積極的に提案してください。

# NoSQL vs SQLite 評価レポート

## 現状分析

### データモデルの実態

現在のスキーマは4テーブル（`collections`, `collection_items`, `collection_item_tags`, `tag_schemas`）＋FTS仮想テーブルで構成されているが、実質的に**ドキュメントストアをSQLiteの上に自前実装している**状態。

根拠：

1. **汎用エンティティテーブル**: すべてのデータが `collection_items` という1つのテーブルに格納される。`persons` も `events` も `tasks` も同じテーブル
2. **スキーマレスの `data` フィールド**: コアデータはJSON blob。`fields_schema` は「ヒント」であり強制されない
3. **リレーションがJSON内**: FK制約ではなく `data` フィールド内のID参照（`related_persons: [3, 5]`）で関係を表現
4. **コレクション＝ドキュメントの型**: `collections` テーブルは実質的にドキュメントタイプの定義

### クエリパターン

| 操作 | 頻度 | 内容 |
|------|------|------|
| コレクション内のアイテム一覧 | 高 | `collection_id` でフィルタ |
| ID でアイテム取得 | 高 | 単純なキールックアップ |
| テキスト検索 | 中 | FTS5 / LIKE フォールバック |
| タグでフィルタ | 中 | junction テーブル経由 |
| ステータスでフィルタ | 中 | 単純な等値条件 |
| 複数テーブルの JOIN | **無** | データの集約クエリが無い |
| トランザクション的な複数テーブル更新 | **無** | 基本的に単一アイテムの CRUD |
| 集計・レポート | **無** | GROUP BY / SUM 等が無い |

**特徴的なのは、RDBの強みであるJOIN・集計・複雑なトランザクションを一切使っていない点。**

---

## 評価

### NoSQL が適している理由（ユーザーの指摘は正しい）

#### 1. データモデルとの自然な適合

```
現状（SQLite）:
collection_items.data = '{"event_date": "2025-01-15", "related_persons": [3, 5]}'
                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
                         → JSONをTEXTカラムに文字列として格納

NoSQL（ドキュメントDB）:
{
  "_id": "item_123",
  "collection": "events",
  "title": "チームミーティング",
  "event_date": "2025-01-15",       ← トップレベルのフィールドとして自然に格納
  "related_persons": [3, 5]          ← ネイティブな配列型
}
```

ドキュメントDBでは `data` フィールドに押し込む必要がなく、各フィールドがファーストクラスの値になる。これにより：
- `data` フィールドの JSON パース/シリアライズが不要
- フィールド単位のインデックスが可能（例: `event_date` で直接クエリ）
- `data` のマージロジック（`item_update` の既存データとの dict merge）が不要

#### 2. スキーマの柔軟性がネイティブ

現在の設計思想は「コレクションごとに異なるフィールドを持ち、スキーマは強制しない」。これはまさにドキュメントDBの設計思想そのもの。SQLiteでこれを実現するために `TEXT NOT NULL DEFAULT '{}'` という妥協をしている。

#### 3. コードの簡素化

現在のコードには SQLite の上にドキュメントストアを模倣するためのボイラーレートが多い：
- `json.dumps()` / `json.loads()` の頻繁な変換（`collections_mod.py` に10箇所以上）
- `_enrich_items()` での手動 JSON パース
- `item_update` での `data` フィールドのマージロジック
- `fields_schema` の JSON 文字列としての格納と復元

#### 4. 参照（リレーション）の扱い

現在の参照はJSON内のIDで、参照整合性は無い。これはドキュメントDBの標準的なパターンと同じ。SQLiteのFK機能を使っていないため、SQLiteを使うメリットがここでも活かされていない。

### SQLite を維持する理由

#### 1. ゼロ依存・組み込み

SQLiteはPython標準ライブラリに含まれる。追加のインストールやプロセス管理が不要。個人用ツールとしてこれは大きな利点。

#### 2. FTS5（全文検索）

SQLiteのFTS5はtrigramトークナイザーを使用しており、日本語検索にも対応。NoSQLに移行した場合、同等の全文検索を実現するには追加の工夫が必要。

#### 3. データ量が小さい

個人用秘書ツールのデータ量は多くても数千〜数万件。この規模ではSQLiteもNoSQLもパフォーマンス差は無視できる。

#### 4. ACID トランザクション

`item_add_batch` のような一括操作でのアトミック性がSQLiteでは簡単に保証される。ただし現在の使用パターンでは複雑なトランザクションは無い。

#### 5. 単一ファイル

`~/.secretary/data.db` という1ファイルで完結。バックアップもコピー1つで済む。

---

## 具体的な選択肢

### 選択肢 A: SQLite を維持（現状維持）

- **変更コスト**: なし
- **メリット**: 動いているものを壊さない
- **デメリット**: JSON変換のボイラープレートが残る

### 選択肢 B: TinyDB に移行

- **概要**: Pure Python のドキュメントDB。JSON ファイルベース
- **変更コスト**: 中（db.py + collections_mod.py の書き換え）
- **メリット**:
  - pip install のみで追加可能（`pip install tinydb`）
  - ドキュメント指向でデータモデルとの親和性が高い
  - JSON変換のボイラープレートが大幅に削減
  - 単一 JSON ファイルで保存（バックアップが容易）
- **デメリット**:
  - FTS が無い（検索はフィールド走査になる）
  - Python 標準ライブラリではない（外部依存追加）
  - 大量データでのパフォーマンスは SQLite に劣る
  - WAL のような並行読み取り最適化が無い

### 選択肢 C: SQLite + JSON1 拡張の活用を強化

- **概要**: 現在の SQLite を維持しつつ、`json_extract()` 等を活用してクエリを改善
- **変更コスト**: 小
- **メリット**:
  - 依存関係の変更なし
  - `data` フィールド内のフィールドに対する直接クエリが可能
  - `json_extract(data, '$.event_date')` でインデックス作成可能
  - FTS5 をそのまま維持
- **デメリット**:
  - ボイラープレートは多少残る
  - データモデルとストレージの不一致は解消されない

### 選択肢 D: UnQLite（組み込みドキュメントDB）

- **概要**: C ベースの組み込みドキュメントDB。Key-Value + ドキュメントストア
- **変更コスト**: 中〜大
- **メリット**:
  - 組み込み型（サーバー不要）
  - ドキュメントネイティブ
  - 単一ファイル
- **デメリット**:
  - Python バインディング（`unqlite-python`）のメンテナンスが不安定
  - FTS サポートが限定的
  - コミュニティが小さい

---

## 結論

**ユーザーの直感は正しい。** データモデルは本質的にドキュメント指向であり、SQLite のリレーショナル機能（JOIN、FK制約、正規化）をほぼ使っていない。SQLite の上にドキュメントストアを模倣している現状は、アーキテクチャとしてやや不自然。

### 推奨

**短期（実用的）**: 選択肢 C — SQLite + JSON1 拡張の活用強化

- 移行リスクがゼロ
- `json_extract()` を使えば `data` 内のフィールドに対するクエリ・インデックスが可能になり、現在の `LIKE` 検索よりも効率的
- FTS5 をそのまま維持できる

**中長期（もしリファクタリングするなら）**: 選択肢 B — TinyDB への移行を検討

- データモデルとの親和性が最も高い
- コードが大幅に簡素化される
- ただし FTS の代替（例: Whoosh や独自のインデックス）の検討が必要
- データ量が小さいため、パフォーマンスの懸念は低い

**避けるべき**: MongoDB 等のサーバー型 NoSQL は個人用ツールにはオーバースペック。
